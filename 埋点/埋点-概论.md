# 埋点-概论

本篇从数据产品经理的角度，描述埋点的定义、原理、埋点工作的核心问题与方案。

## 1. 概述

#### 1.1 什么是埋点

**埋点** = **埋**入一个监控**点**，在某个位置放置监视器，记录下关注的场景（历史），为后续分析提供依据。监控摄像头相当于一个埋点，蹲在街上数路过的车辆也是一个“人肉埋点”，在互联网应用中指的就是**通过代码记录事件**。埋点最终的目的是为数据服务（分析、计算等）提供基础的数据“弹药”。通常情况下，埋点采集的数据会经历以下过程：

1.  数据生产者：客户端或服务端，通过埋点生成日志数据，传给管道/中转站

2.  管道/中转站：消息收集、处理和发布系统，收集各个数据发送方的数据并进行处理和存储，供消费者使用

4.  数据消费者：业务方、数据平台等，从管道获取数据，根据需求做进一步开发和存储

埋点发生在数据生产者侧，是整个数据流动的**源头**，埋点的质量（流量、粒度、易用性等）很大程度上影响到后续的每一个环节。



#### 1.2 埋点管理工作的核心问题

埋点的本质是生产数据，最终要服务于数据消费者，埋点的系统位置以及消费者（业务）怎么使用数据，决定了要采取哪些方案。

埋点数据常见的应用场景有：

1.  记录用户的行为：产品逻辑优化；基于用户画像的精细化运营、推荐、营销等；风控
2.  记录业务数据：支持业务功能；业务数据分析
3.  记录系统状况：供开发人员在系统优化时参考

从埋点需要达到的效果上看，有这几方面的要求：

1.  覆盖度：数据采集能否覆盖需要关注的场景
2.  粒度：数据能精细到什么程度？全站？某个场景？还是单次行为？
3.  维度：是否支持从多个角度去解读数据
4.  时效性：通常情况下数据的价值随时间降低，越快取得数据，越能发挥数据的作用
5.  准确性：能否满足不同使用场景下对数据的精确度要求

结合以上要求，埋点工作有以下几个核心问题需要解决：

1.  WHERE —— 埋点位置
2.  HOW —— 实现方式
3.  WHEN —— 何时触发埋点
4.  WHAT —— 采集什么内容
5.  HOW  —— 数据如何上报



## 2. 埋点位置

即埋点代码要写在哪里。代码位置的选择，关系到数据生产的覆盖度、可靠性和效率。

#### 2.1 客户端埋点(app/h5/web）

客户端即用户设备上的应用。

客户端作为数据生产者有以下优势：

1.  可以较全面的采集用户的设备和网络信息
2.  可以感知到用户在应用中的几乎所有行为

这两个优点决定了业内绝大多数方案都采用了客户端埋点方案，但客户端埋点缺点同样明显：

1.  生效周期长：代码写在应用包里，上线更新依赖于客户端发版，需要用户主动升级客户端才能生效。这就导致对于新增的埋点，只能从某一个版本开始才能向后收集数据，无法覆盖不升级的老用户，而等待大部分用户更新，可能要两周甚至更久。对于新增的业务可能影响不大，但是对于旧业务的新埋点，则很长一段时间都无法取得全面准确的数据。此外这种方式的容错率也很低，一旦某个版本上线后发现bug，很有可能导致某些数据被长期污染，无法使用。
2.  受本地存储空间和流量制约：采集数据量大时，需要的缓存空间和上传数据时耗费的流量也相应变大，为了保证产品性能和用户体验，需要采用延时上报、压缩打包上报等策略，就降低了数据采集的时效性和准确性（打包上报丢包率更高）。
3.  受客户端稳定性影响：客户端会因为各种意外情况导致程序运行中断或无法传输数据，如接听电话、退后台、杀死APP、死机、断电、断网等，有些情况可以将数据保存在本地，等待正常运行时再上报，这样时效性会被降低。有些情况如突然死机等，有些数据就来不及被保存，直接丢失。

适合采用前端埋点的情况：

1.  前端可感知的，或无需向服务端发起请求的事件；

2.  部分请求服务端响应但失败，而服务端无法感应到失败请求的情况，如无网络连接导致的失败，在前端埋点用于补全场景或进行异常分析；

3.  安全性、时效性、准确性要求不高的。 

上报依赖于前端的联网情况、上报机制，相对于服务端埋点更可能丢失部分数据；数据质量方面，若线上方案有BUG，则产生错误数据，除了个别运气好的情况，基本无法在数据开发阶段进行弥补

#### 2.2 服务端埋点

触发了服务端接口响应的事件；

常用于对准确度要求更高的时间统计

除了前端完全不向服务端发起请求操作，其他尽量都使用服务端埋点，部分埋点需要客户端配合发送一些数据到服务端（通过服务API），然后由服务端上报 

优点：更新方面，服务端发版比客户端端更简单快捷，无需等待用户更新；上报方面服务端网络更可靠； 

缺点：服务端可能不关心很多客户端参数，上报时需要客户端进行补充；服务端采集的一般只包括登录状态用户的数据

#### 2.3 客户端vs服务端

|                | 客户端 | 服务端 |
| -------------- | ------ | ------ |
| 设备与网络信息 |        |        |
| 用户行为采集   |        |        |
| 业务数据采集   |        |        |
| 数据准确性     |        |        |
| 代码更新       |        |        |



##  3.实现方式

这部分是从 “埋点实现的自动化程度” 角度来看埋点的实现方式，不涉及具体的开发。

#### 3.1 代码埋点/自定义埋点

是目前埋点方案的主流形式

原理：客户端触发节点时，调用相应的SDK方法通过接口发送数据，如点击某个按钮时，在按钮点击onclilck函数中调用SDK上报数据。适用场景：业务简单，埋点轻便灵活，工作量不大优点：缺点：沟通成本高：运营、产品、产品前后端、数据前后端全都要参与，系统版本管理困难埋点周期长业务复杂时维护难、重复操作成本高

#### 3.2 全埋点/无埋点

定义：对于**所有**可能关注的系统事件（如控件的加载成功、浏览、点击、播放等），**自动地**采集并存储，当需要的时候，**找到关心的数据**，进行处理和分析。

关键词1——所有：意味着一切设定范围内的事件都将被统计，比如有3个按钮A、B、C，你目前只分析其中按钮A的点击情况，并不关心B和C有没有人点，但这2个按钮的点击情况依然会被记录下来。这样做的优点是历史可追溯，当你有一天突然关心B和C了，只需要找到这些数据就可以用。缺点也很容易理解，一是传输成本高，耗费了更多的客户端流量，通常采用打包压缩的方式缓解；二是存储成本高，所以通常对于未关注的数据，设置销毁时限，到期未被使用的数据将被删除。

关键词2——自动采集：全埋点的核心是自动化，当埋点SDK部署后，任何规范范围内的控件事件，都会被自动部署埋点代码，无需开发人员额外操作。优点主要有两个，一是大大降低了开发和沟通成本，二是自动化采集的数据会更加规范、统一，方便后续处理。但是通用的自动化往往牺牲了个性化，对于复杂的场景、一些不“通用”的自定义属性、一些控件的细节属性，全埋点方案难以针对性地实现，可以和手动代码埋点方案相结合来弥补。粗糙的全埋点方案，在页面或控件路径修改时，数据的使用方案也要随之修改，可以通过约定更多的细节，使用不易变的属性来缓解这个问题。

关键词3——找到关心的数据：全量数据那么多，哪些才是我关心的数据呢？就好比在全校学生中找某个班的学生，你就必须知道要找的班级号，全埋点中控件/事件的数据，同样要有能够唯一识别的方式。这需要一套规定好的方案，使用唯一的控件路径、唯一的控件名等。唯一标识设计为自动生成，一次开发成本高，但维护成本低，或者手动给控件命名，后期维护麻烦。

补充关键词：可视化埋点可视化埋点是全埋点方案的一种，通常全埋点指在SDK部署时就开始尽可能收集所有数据，只在分析阶段通过可视化的配置选择要分析哪些数据，可视化埋点的理解有两种，一是在全埋点的基础上提供了可视化的配置方式，二是在配置了想要收集的数据之后才开始向后收集，没有历史数据。

结合以上特点，全埋点适用于：

-   无需深入分析（自定义能力差）
-   业务多变（较低的开发和沟通成本）
-   页面逻辑变化少（降低数据使用的复杂度）



##  4. 埋点时机



复杂操作可能要细化到具体的代码执行步骤：如：操作 != 操作成功，操作是前端响应，操作成功通常指服务端响应成功；如：APP启动的短时间内会经历启动图、广告、浮层、权限、弹窗等许多行为，要考虑上报顺序对路径分析的影响



##  5. 采集内容

#### 5.1 数据来源

客户端：客户端程序能够感知的所有内容，包括用户操作、系统进程等

服务端：同步服务端日志或进行服务端埋点，常用于前端无即时感知的事件统计（如审核结果）、精确统计业务数据（和业务调用是同步的）



#### 5.2 事件

事件 = 环境+实体属性+行为+其他自定义属性

##### 3.2.1 环境

时间：操作发生的时间；操作持续的时间

空间：

-   现实空间：GPS；
-   设备空间：网络（3G/4G/5G/wifi、ip）；设备信息（厂商、型号、imei、操作系统）
-   应用空间：应用版本；应用内位置来源：从什么地方来到了当前场景

##### 3.2.2 实体

实体包括用户

**用户**

人口、社会属性：姓名、性别、年龄、常住地、职业、消费能力、偏好等

业务属性：用户在平台内的身份、偏好、安装渠道、注册渠道等

**用户的唯一标识**

什么是一个用户的唯一标识？为什么要唯一标识？

身份证就是最常见和易理解的唯一标识。唯一标识代表一个用户在系统中的身份，在用户画像构建、行为分析、漏斗分析等几乎任何数据分析的场景都必不可少，常用的唯一标识有注册账号、设备号、手机号等。

唯一标识一个用户所面临的问题

-   用户行为：实际情况中用户的行为很复杂，一个用户可能有多个账号或多个设备、一个设备上有多个用户的多个账号、一个账号在多个设备上登录、或用户无登录；将设备号视为一个用户将会忽视一号多机的情况、将一个账号视为一个用户会忽视多人共用的情况，需要结合具体业务场景决定方案
-   覆盖度：不同字段的覆盖度也不同，有些可能因为隐私等原因难以获取（如身份证、手机号、imei号），或天然覆盖不全（如游客用户）
-   安全性：在生产、传输和存储的过程中有可能泄露用户隐私
-   稳定性：用户的任何唯一标识都是有可能会发生变化的，身份证、手机号的变更属于不可控的，但对于同一设备安装的同一应用，应保证设备id是唯一的，不因卸载重装、升级等原因发生变化

**客体（行为对象）**

定义：被操作对象可能是控件或被理解为一个内容（文本、图片、音视频）

唯一标识：控件在某些场景下也有唯一标识的需要，如区分同一类按钮在不同位置的点击，通过技术方案可以比较容易地解决

常用的属性：物品/内容/信息id（商品id、视频id、消息id等）；分类id（如专辑id、播单id、收藏夹id等）；时长、清晰度、分辨率、音质、尺寸、文件大小等文件信息

**行为**

主动行为：用户具体操作如点赞、评论、搜索、购买；

被动行为：如评论失败、审核通过、push接收、广告弹窗等

为降低数据上传压力，常用actionId（行为id，数字或简单字符串）来代表不同的行为，在埋点管理系统中对actionId代表的行为进行详细描述；被动行为要考虑上报时机和来源，app是否存活、客户端报还是服务端报。

**其他自定义属性**

通常出于分析目的自定义的生成属性。

计时类字段：统计某个事件持续的时间，上报前直接计算出时间段或者上报消息时间点，后续处理中计算时间段。

路径类字段：用于统计某个事件用于追踪一个完整行为的来源、去向、或一个session内的所有操作等，如APP启动时生成一个stratId，该用户在退出APP前的所有数据都附带这个字段值，这些数据被视为用户单次启动所产生的行为；或从某个渠道安装或调起APP的，在有效期内都带上渠道id。

反作弊类字段：防刷码等

##### 3.2.3 事件设计原则

1.详细：任何业务会关心的内容都可以作为事件去统计，常见的如用户行为、系统性能等

2.一致性：若产品在iOS、Android、ipad等多平台，对于同一事件的口径、名称、埋点时机、上报数据等应完全一致

3.必要的冗余：上报内容中其实有很多字段都是冗余的，在一些服务端通过关联可以得到，但是当数据量很大时，关联计算相当困难，冗余上报可以减少关联步骤

4.复用：当现存的事件无法很好的解释新场景，或通用字段无法覆盖新增场景值时，再新增一个事件，否则尽可能的复用。但也要避免过度复用，复用通常会导致‘部分修改、全部改变’的情况，不够灵活。复用时要考虑将来是否有可能被大规模使用，若有可能，则要提前做好准备，看该模式是否具有大规模生产、开发的性能，如不能满足，要及时优化，避免规模过大以后难以优化。

#### 3.3 字段设计

流程：首先建立业务数据模型，再逆推到底层需要的字段

内容：尽可能全面的采集当时的环境数据，提供了更多维度也更方便还原现场；做必要的冗余，用于减少下一步的数据开发工作量；尽量的复用已有的字段，减少开发量

拓展性：原有的字段可能无法满足需求，但是也没有必要进行基础字段改造时，使用拓展字段，在数据开发时进行二次加工产生新字段，如套娃一个字符串类型的字段，用JSON字典或URL parameters存储拓展参数，便于二次加工处理

一致性：口径、字段类型和规范保持一致，字段类型不一致会数据开发流程中的计算问题，口径不一致则数据不具备可用性，或需要重新开发

字段值的获取：接口获取，业务系统返回的业务数据、实体的属性数据、统计系统下发的标识数据等；前端自定义固定值、判断值、计算值

#### 3.4 埋点时机



#### 3.5 质量与效率

排重：减少无意义重复数据的干扰

减压：屏蔽不必要的数据采集

取值明确：可全部枚举的取值（默认值、错误值、正常值区间）



## 5. 数据的上报

#### 5.1 上报时机与方式

主要从可靠性和即时上报，通常用于对时效性要求较高的；延时上报，通常用于给数据量较大的场景减压，数据打包压缩后上报，丢包率高。

上报条数：单条发送；积累一定数量打包发送

#### 5.2 传输方式

**http协议传输**

url传参、contents传参

post方法和get方法

**传输性能**

安全性：客户端数据加密**，**防止数据泄露、防止恶意伪造数据进行作弊操作（加密的数据难以仿造）

可靠性：上报数据都先缓存在本地，上报成功或达到一定条件之后再删除，对于重要的数据，使用失败重试机制，数据上报应返回上报情况，失败时有限次的重复尝试，达到失败次数上限时等待下个时机重试，（数据接收和清洗环节，要考虑错误的重试产生的大量重复数据。）；数据丢失的容忍程度根据使用场景决定，看趋势数据、整体分析等，不需要过于精确，用于重要核心业务、设计支付、订单等，要求尽可能100%可靠

时效性：实时上报、延时上报（考虑性能）

性价比：延时上报、打压缩包上报可以缓解流量和带宽开销；简化数据，上报文档中约定好的map-key，如1=成功；2=失败，而不是success/failure



## 6. 数据的预处理、存储与开发







## 7. 埋点管理

接口与格式、事件、表





## 8. 埋点工作的日常

#### 8.1 工作流程闭环

了解业务流程：根据业务流程，选择一种或多种数据采集方案；尽量在业务开发前介入，帮助共同制定既有利于业务健康使用数据、也利于数据采集的系统。

调研行业情况：和业务人员共同确认关键指标和流量模型

确认埋点方案：



#### 8.2 SQL民工

无情的取数机器



#### 8.3 容忍不完美

容忍【不完美】、【不准确】、【不全面】、【被污染】



## 参考文章

1.  神策数据-技术文档 https://manual.sensorsdata.cn/sa/latest/

2.  PMCAFF 《数据产品经理：埋点的设计、管理与应用》https://mp.weixin.qq.com/s/mjnpTAR0HKx-YexA9H5VIg