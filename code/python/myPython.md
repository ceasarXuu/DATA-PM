# 笔记-《利用python进行数据分析》

---

## 1. 数据结构

### 字典

**创建**

```python
# 普通创建
empty_dict = {key:value, key:value}
# 用序列创建1 
mapping	= {}
for	key, value in zip(key_list,	value_list):
	mapping[key] = value
# 用序列创建2
mapping = dict(zip(range(5), reversed(range(5))))
# 默认值
value = some_dict.get(key, default_value)
```

## 2. 内置函数

blabla

## 3. 重要模块

### numpy

>   数据分析的主要工具

#### ndarry

**特性**

同构数据多维容器（数组）：对于面向数组处理提供了很好的功能。

视图：视图是指与较大数组共享相同数据的较小数组。因为是共享数据，所以修改小数组中的数据会影响大数组。正是因为视图的存在，numpy的运算速度才快。

**创建**

`arr.dtype`查询数组的类型  
`arr.ndim`查看数组的维数  
`arr.shape`查看数组的形状  
`arr.zeros()`/`arr.ones()`创建指定形状的float64类型的全是0/1的数组  
`arr.empty()`创建指定形状的、没有具体值（随机）的数组   
`arr.arange()`类似range函数，但返回的是一个ndarry对象  

**数据类型**

```arr1 = np.array([2, 3], dtype='float64')```
astype:转换数组数据类型，使用时创建一个新的数组
使用 ```numpy.string_``` 类型时注意，字符截取不会警告

**数组运算**

- 不用编写循环即可进行矢量化运算
- 数组间：
    -   大小相等的数组间的运算都会应用到元素级
    -   大小相等的数组间比较会得到布尔数组
    -   大小不同的数组间运算叫广播broadcasting
- 数组与标量：标量值会广播到每个元素

**切片与索引**

ndarry的切片是源ndarry的视图（可以理解为局部引用），==改变切片的值也会表现在源数组中==，若要使用切片的副本，应当使用 ```.copy()```；多维的切片使用 ```arr2d[1:2, 2:3]```来表示； 多维索引中，```arr2d[0][2]``` 和```arr2d[0,2]```是等价的； 混合切片索引`arr2d[1, :2]`可以取得第二行的前两列；

布尔索引：通过传入布尔索引（数组），取得数组中索引值为true的元素；使用条件是布尔数组的长度要与被索引的轴的长度一致，否则会出错；布尔索引同样可以和切片、整数等混合使用；布尔索引的生成可以利用很多布尔运算的技巧；通过==布尔索引选取的数组，将总是创建数据副本==，即不会改变源数组；

花式索引：使用整数数组进行指定位置的索引；花式索引将创建数据副本；

**数组转至与轴对换**

`arr.T` 每个数组都有一个T属性，返回数组的简单转置（兑换轴）

`arr.transpose((1,0,2))` transpose方法需要传入一个由编号组成的元组，此例中表示第一个轴换到了第二个，第二个轴换到了第一个，第三个轴不变。

`arr.swapaxes(1,2)`swapaxes方法需要接受一对轴编号，进行对换

**通用函数（ufunc）**

指对ndarry执行元素级运算的函数；

ufuncs接受out选项参数，可以在数组原地进行操作（直接改变源数组）`np.sqrt(arr, arr) # 第二个arr就是out参数位`

**利用数组进行数据处理**

矢量化：利用数组表达式代替循环，提高效率（比等价纯python方式快1~2个数量级，甚至更多）

逻辑条件在数组运算中的应用——where函数：`np.where(cond, xarr, yarr)`当cond中的值为True，选xarr的值，否则选yarr的值。

数学和统计方法：一些聚合、约简等数学函数可以对整个数组或某个轴向进行统计

用于布尔型数组的方法：数组中的布尔值在数学函数中被转换为0和1进行计算，`bool_arr.sum()`方法常用于计算true的个数；`bool_arr.any()`方法检查是否至少存在一个Ture；`bool_arr.all()`检查是否全是True

排序

