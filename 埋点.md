# 埋点

[toc]

## 1. 概述

#### 1.1 什么是埋点

**埋点** = **埋**入一个监控**点**，在某个位置放置监视器，记录下关注的场景，为分析提供依据。监控摄像头相当于一个埋点，蹲在街上数路过的车辆也是一个“人肉埋点”，在互联网应用中就是通过代码记录事件。



#### 1.2 埋点的作用

埋点常见的应用场景有

-   记录用户的行为：产品逻辑优化、生成用户画像、精细化运营、推荐、营销等
-   记录系统状况：供开发人员在系统优化时参考



#### 1.3 数据的流动

采集 →传输→清洗→存储→计算→分析/可视化采集对下游每个环节都会产生影响，优质的采集方案很重要



## 2. 埋点类型

#### 2.2 按埋点自动化程度分

##### 2.2.1 代码埋点/自定义埋点

是目前埋点方案的主流形式

原理：客户端触发节点时，调用相应的SDK方法通过接口发送数据，如点击某个按钮时，在按钮点击onclilck函数中调用SDK上报数据。适用场景：业务简单，埋点轻便灵活，工作量不大优点：缺点：沟通成本高：运营、产品、产品前后端、数据前后端全都要参与，系统版本管理困难埋点周期长业务复杂时维护难、重复操作成本高

##### 2.2.2 全埋点/无埋点

定义：对于**所有**可能关注的系统事件（如控件的加载成功、浏览、点击、播放等），**自动地**采集并存储，当需要的时候，**找到关心的数据**，进行处理和分析。

关键词1——所有：意味着一切设定范围内的事件都将被统计，比如有3个按钮A、B、C，你目前只分析其中按钮A的点击情况，并不关心B和C有没有人点，但这2个按钮的点击情况依然会被记录下来。这样做的优点是历史可追溯，当你有一天突然关心B和C了，只需要找到这些数据就可以用。缺点也很容易理解，一是传输成本高，耗费了更多的客户端流量，通常采用打包压缩的方式缓解；二是存储成本高，所以通常对于未关注的数据，设置销毁时限，到期未被使用的数据将被删除。

关键词2——自动采集：全埋点的核心是自动化，当埋点SDK部署后，任何规范范围内的控件事件，都会被自动部署埋点代码，无需开发人员额外操作。优点主要有两个，一是大大降低了开发和沟通成本，二是自动化采集的数据会更加规范、统一，方便后续处理。但是通用的自动化往往牺牲了个性化，对于复杂的场景、一些不“通用”的自定义属性、一些控件的细节属性，全埋点方案难以针对性地实现，可以和手动代码埋点方案相结合来弥补。粗糙的全埋点方案，在页面或控件路径修改时，数据的使用方案也要随之修改，可以通过约定更多的细节，使用不易变的属性来缓解这个问题。

关键词3——找到关心的数据：全量数据那么多，哪些才是我关心的数据呢？就好比在全校学生中找某个班的学生，你就必须知道要找的班级号，全埋点中控件/事件的数据，同样要有能够唯一识别的方式。这需要一套规定好的方案，使用唯一的控件路径、唯一的控件名等。唯一标识设计为自动生成，一次开发成本高，但维护成本低，或者手动给控件命名，后期维护麻烦。

补充关键词：可视化埋点可视化埋点是全埋点方案的一种，通常全埋点指在SDK部署时就开始尽可能收集所有数据，只在分析阶段通过可视化的配置选择要分析哪些数据，可视化埋点的理解有两种，一是在全埋点的基础上提供了可视化的配置方式，二是在配置了想要收集的数据之后才开始向后收集，没有历史数据。

结合以上特点，全埋点适用于：

-   无需深入分析（自定义能力差）
-   业务多变（较低的开发和沟通成本）
-   页面逻辑变化少（降低数据使用的复杂度）

#### 2.2 按埋点位置分

##### 2.2.1 客户端埋点(app/h5/web）

常用于用户行为分析；前端可感知的，或无需向服务端发起请求的事件；部分请求服务端响应但失败，而服务端无法感应到失败请求的情况，如无网络连接导致的失败，在前端埋点用于补全场景或进行异常分析；安全性、时效性、准确性要求不高的。 缺点：更新依赖于客户端发版，无法分析过往未收集的数据，生效周期长，影响业务分析；上报依赖于前端的联网情况、上报机制，相对于服务端埋点更可能丢失部分数据；数据质量方面，若线上方案有BUG，则产生错误数据，除了个别运气好的情况，基本无法在数据开发阶段进行弥补 优点：可以拿到第一手客户端数据 APP与H5打通问题：？？？

##### 2.2.2 服务端埋点

需要服务端响应才能完成的事件；

除了前端完全不向服务端发起请求操作，其他尽量都使用服务端埋点，部分埋点需要客户端配合发送一些数据到服务端（通过服务API），然后由服务端上报 

优点：更新方面，服务端发版比客户端端更简单快捷，无需等待用户更新；上报方面服务端网络更可靠； 

缺点：服务端可能不关心很多客户端参数，上报时需要客户端进行补充



##  3. 埋点数据的生产与管理

数据的生产方式和传输方式是紧密相关的，互相影响

#### 3.1 数据来源

客户端：客户端程序能够感知的所有内容，包括用户操作、系统进程等

服务端：同步服务端日志或进行服务端埋点，常用于前端无即时感知的事件统计（如审核结果）、精确统计业务数据（和业务调用是同步的）



#### 3.2 事件

事件 = 环境+实体属性+行为+其他自定义属性

##### 3.2.1 环境

时间：操作发生的时间；操作持续的时间

空间：

-   现实空间：GPS；
-   设备空间：网络（3G/4G/5G/wifi、ip）；设备信息（厂商、型号、imei、操作系统）
-   应用空间：应用版本；应用内位置来源：从什么地方来到了当前场景

##### 3.2.2 实体

实体包括用户

**用户**

人口、社会属性：姓名、性别、年龄、常住地、职业、消费能力、偏好等

业务属性：用户在平台内的身份、偏好、安装渠道、注册渠道等

**用户的唯一标识**

什么是一个用户的唯一标识？为什么要唯一标识？

身份证就是最常见和易理解的唯一标识。唯一标识代表一个用户在系统中的身份，在用户画像构建、行为分析、漏斗分析等几乎任何数据分析的场景都必不可少，常用的唯一标识有注册账号、设备号、手机号等。

唯一标识一个用户所面临的问题

-   用户行为：实际情况中用户的行为很复杂，一个用户可能有多个账号或多个设备、一个设备上有多个用户的多个账号、一个账号在多个设备上登录、或用户无登录；将设备号视为一个用户将会忽视一号多机的情况、将一个账号视为一个用户会忽视多人共用的情况，需要结合具体业务场景决定方案
-   覆盖度：不同字段的覆盖度也不同，有些可能因为隐私等原因难以获取（如身份证、手机号、imei号），或天然覆盖不全（如游客用户）
-   安全性：在生产、传输和存储的过程中有可能泄露用户隐私
-   稳定性：用户的任何唯一标识都是有可能会发生变化的，身份证、手机号的变更属于不可控的，但对于同一设备安装的同一应用，应保证设备id是唯一的，不因卸载重装、升级等原因发生变化

**客体（行为对象）**

定义：被操作对象可能是控件或被理解为一个内容（文本、图片、音视频）

唯一标识：控件在某些场景下也有唯一标识的需要，如区分同一类按钮在不同位置的点击，通过技术方案可以比较容易地解决

常用的属性：物品/内容/信息id（商品id、视频id、消息id等）；分类id（如专辑id、播单id、收藏夹id等）；时长、清晰度、分辨率、音质、尺寸、文件大小等文件信息

**行为**

主动行为：用户具体操作如点赞、评论、搜索、购买；

被动行为：如评论失败、审核通过、push接收、广告弹窗等

为降低数据上传压力，常用actionId（行为id，数字或简单字符串）来代表不同的行为，在埋点管理系统中对actionId代表的行为进行详细描述；被动行为要考虑上报时机和来源，app是否存活、客户端报还是服务端报。

**其他自定义属性**

通常出于分析目的自定义的生成属性。

计时类字段：统计某个事件持续的时间，上报前直接计算出时间段或者上报消息时间点，后续处理中计算时间段。

路径类字段：用于统计某个事件用于追踪一个完整行为的来源、去向、或一个session内的所有操作等，如APP启动时生成一个stratId，该用户在退出APP前的所有数据都附带这个字段值，这些数据被视为用户单次启动所产生的行为；或从某个渠道安装或调起APP的，在有效期内都带上渠道id。

反作弊类字段：防刷码等

##### 3.2.3 事件设计原则

1.详细：任何业务会关心的内容都可以作为事件去统计，常见的如用户行为、系统性能等

2.一致性：若产品在ios、Android、ipad等多平台，对于同一事件的口径、名称、埋点时机、上报数据等应完全一致

3.必要的冗余：上报内容中其实有很多字段都是冗余的，在一些服务端通过关联可以得到，但是当数据量很大时，关联计算相当困难，冗余上报可以减少关联步骤

4.复用：当现存的事件无法很好的解释新场景，或通用字段无法覆盖新增场景值时，再新增一个事件，否则尽可能的复用。但也要避免过度复用，复用通常会导致‘部分修改、全部改变’的情况，不够灵活。复用时要考虑将来是否有可能被大规模使用，若有可能，则要提前做好准备，看该模式是否具有大规模生产、开发的性能，如不能满足，要及时优化，避免规模过大以后难以优化。

#### 3.3 字段设计

流程：首先建立业务数据模型，再逆推到底层需要的字段

内容：尽可能全面的采集当时的环境数据，提供了更多维度也更方便还原现场；做必要的冗余，用于减少下一步的数据开发工作量；尽量的复用已有的字段，减少开发量

拓展性：原有的字段可能无法满足需求，但是也没有必要进行基础字段改造时，使用拓展字段，在数据开发时进行二次加工产生新字段，如套娃一个字符串类型的字段，用JSON字典或url parameters存储拓展参数，便于二次加工处理

一致性：口径、字段类型和规范保持一致，字段类型不一致会数据开发流程中的计算问题，口径不一致则数据不具备可用性，或需要重新开发

字段值的获取：接口获取，业务系统返回的业务数据、实体的属性数据、统计系统下发的标识数据等；前端自定义固定值、判断值、计算值

#### 3.4 埋点时机

复杂操作可能要细化到具体的代码执行步骤：如：操作 != 操作成功，操作是前端响应，操作成功通常指服务端响应成功；如：APP启动的短时间内会经历启动图、广告、浮层、权限、弹窗等许多行为，要考虑上报顺序对路径分析的影响

#### 3.5 质量与效率

排重：减少无意义重复数据的干扰

减压：屏蔽不必要的数据采集

取值明确：可全部枚举的取值（默认值、错误值、正常值区间）



## 4. 数据上报与传输

#### 4.1 上报时机与方式

##### 4.1.1上报时机

主要从可靠性和即时上报，通常用于对时效性要求较高的；延时上报，通常用于给数据量较大的场景减压，数据打包压缩后上报，丢包率高。

##### 4.1.2 上报方式

上报条数：单条发送；积累一定数量打包发送

#### 4.2 传输方式

**http协议传输**

url传参、contents传参

post方法和get方法

**传输性能**

安全性：客户端数据加密**，**防止数据泄露、防止恶意伪造数据进行作弊操作（加密的数据难以仿造）

可靠性：上报数据都先缓存在本地，上报成功或达到一定条件之后再删除，对于重要的数据，使用失败重试机制，数据上报应返回上报情况，失败时有限次的重复尝试，达到失败次数上限时等待下个时机重试，（数据接收和清洗环节，要考虑错误的重试产生的大量重复数据。）；数据丢失的容忍程度根据使用场景决定，看趋势数据、整体分析等，不需要过于精确，用于重要核心业务、设计支付、订单等，要求尽可能100%可靠

时效性：实时上报、延时上报（考虑性能）

性价比：延时上报、打压缩包上报可以缓解流量和带宽开销；简化数据，上报文档中约定好的map-key，如1=成功；2=失败，而不是success/failure



## 5. 数据存储





## 6. 数据开发





## 7. 埋点工作的日常

了解业务流程：根据业务流程，选择一种或多种数据采集方案；尽量在业务开发前介入，帮助共同制定既有利于业务健康使用数据、也利于数据采集的系统。

调研行业情况：和业务人员共同确认关键指标和流量模型

确认埋点方案：



## 8. 专题调研

#### 8.1 移动设备标识码

##### 8.1.1 Android设备

| 名称     | 说明                                                         | 格式                                                         | 获取方式                                                     | 应用                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| IMEI     | 国际移动设备识别码（International Mobile Equipment Identity）相当于移动电话的身份证，存在主板内存中，双卡双待手机有两个imei号。用于GSM设备。不会改变 | 15~17位，十进制，前8位（TAC）是型号核准号码（早期为6位），是区分手机品牌和型号的编码。接着2位（FAC）是最后装配号（仅在早期机型中存在），代表最终装配地代码。后6位（SNR）是串号，代表生产顺序号 | 安卓8.0以上用getImei获取，8.0以下用TelephonyManager.getDeviceId()，需要获取READ_PHONE_STATE 权限 | 重装APP不会改变                                              |
| MEID/ESN | 移动设备识别码(Mobile Equipment Identifier)，类似imei，用于CDMA制式的移动设备 | 14位，十六进制，RR – 有效范围 ’99’, ’98’, ’97’ ，全球统一管理；XXXXXX – 有效范围 000000--999999；ZZZZZZ – 有效范围 000000-- 999999；C – 有效范围 0 -- 9 – 不参与空中传输。 | 安卓8.0以上用getMeid获取，8.0以下用TelephonyManager.getDeviceId()，需要获取READ_PHONE_STATE 权限 | CDMA设备返回的，一般不使用                                   |
| MAC      | 网络地址（Media Access Control Address）在网络中唯一标识一个网卡，一台设备中的多个网卡有多个MAC地址，烧制在网卡EPROM中。包括WiFi mac地址和蓝牙mac地址 | 48位，二进制，常表示为12个16进制数，前6个是制造商编号，后6个是网络产品（网卡）的系列号 | INTERNET、ACCESS_WIFI_STATE、ACCESS_NETWORK_STATE<br /> Android 6.0之后被禁止，若获取则会被判定为有害应用。 | 用于确认网络设备位置，一般与IMEI一起使用定位一台设备         |
| IMSI     | 国际移动用户识别码	（International Mobile Subscriber Identity）用于蜂窝网络中唯一确定一个用户，存在SIM卡（CDMA2000中存在手机或RUIM），双卡手机只返回一个IMSI，用户换手机、换卡不换号，都不变 | 最大15位，绝大多数为15位，十进制。	由移动国家代码（MCC，Mobile Country Code）、	移动网络代码	（MNC，Mobile Network Code）和移动订户识别代码（MSIN，Mobile subscription identification number）依次连接而成 | READ_PHONE_STATE<br/>TelephonyManager.getSubscriberId()      | 用户更换手机时仍可使用                                       |
| ICCID    | SIM卡卡号（Integrate circuit card identity）用于区分每张SIM卡，可以伪造，双卡手机只返回一个ICCID | 19~20位，少数6/12位，十进制。前6位是运营商代号               | READ_PHONE_STATE<br/>TelephonyManager.getSimSerialNumber()   | 区分运营商                                                   |
| UUID     | 通用唯一识别码(Universally Unique Identifier)，由随机算法得到的伪唯一识别码（重复概率为170亿分之一），每次获取都会改变。应用最广泛的是微软的GUIDs |                                                              |                                                              | 用于生成UDID                                                 |
| UDID     | 设备唯一标识符（Unique Device Identifier），通常是非系统原生的，开发商自定义解决。 |                                                              |                                                              | 获取UUID后，写入.so文件生成UDID。即使APP重装，值也不变，除非root手机（普通用户做不到） |

##### 8.1.2 iOS设备

| 名称     | 说明                                                         | 格式                                                         | 获取方式       | 应用                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------- | ------------------------------------------------------------ |
| IDFV     | 应用开发商标识符（Identifier For Vendor），同一开发商的应用的IDFV都一样。当用户卸载某应用商的所有应用，重装该应用商的应用时，IDFV改变 | 通过CFBundleIdentifier（DNS反转格式）的前两部分生成，如：com.cjh.one和com.cjh.two得到的IDFV是一样的。如（583D2BB0-B19C-4A9A-A600-2A1EB2FB7E39 ） |                |                                                              |
| IDFA     | 广告标识符（Identifier For Advertising）苹果专门给各广告提供商用来追踪用户而设的，由系统存储，用户可以主动还原隐私、还原广告标识符、开关IDFA开关、充值系统来改变这个值。同一设备的所有应用拿到的都是同一个IDFA |                                                              |                | 跨应用的用户追踪、广告推广                                   |
| UUID     | 通用唯一识别码(Universally Unique Identifier)，由随机算法得到的伪唯一识别码（重复概率为170亿分之一），每次获取都会改变。应用最广泛的是微软的GUIDs |                                                              |                | 将第一次获取的UUID存到keychain中，之后每次都使用keychain，就成为不变的唯一ID |
| IMEI     | 国际移动设备识别码（International Mobile Equipment Identity） |                                                              | ios5后禁止获取 |                                                              |
| UDID     | 设备唯一标识符（Unique Device Identifier）可以唯一锁定一台设备，只有越狱可以改变 |                                                              | ios5后弃用     |                                                              |
| OpenUDID | 开源方案，利用剪切板在不同应用间共享一个OpenUDID             |                                                              | ios7后弃用     |                                                              |
| MAC      | 网络地址（Media Access Control Address）                     |                                                              | ios7后禁止获取 |                                                              |

#### 8.2 如何唯一标识一个用户





#### 8.3 时长的统计

都是使用消息节点之间的时间差进行的，关键在于要采集哪些节点，节点之间的时间用于哪些指标的计算

##### 8.3.1 移动端APP页面停留时长

统计数据用途

-   用户行为数据分析
-   路径分析

#### 8.4 上报时机

